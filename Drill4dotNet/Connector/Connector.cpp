#include "pch.h"

#include "Connector.h"

// A hack to solve GNU-specific artifact generated by Kotlin native 1.3.70
#define __attribute__(x) 
#include "agent_connector_api.h"
#undef  __attribute__

#include <typeinfo>
#include <stdexcept>
#include <iostream>
#include <filesystem>
#include <queue>
#include <mutex>

namespace Drill4dotNet
{
    class Connector : public IConnector
    {
    protected:
        static const std::filesystem::path CONNECTOR_DLL_FILE;
        static HMODULE s_library;
        static decltype(agent_connector_symbols)* fn_agent_connector_symbols;
        static decltype(initialize_agent)* fn_initialize_agent;
        static decltype(sendMessage)* fn_sendMessage;
        static std::queue<std::string> m_messages;
        static std::mutex m_mutex;
        static HANDLE m_event;

    protected:
        // is called by Kotlin native connector to transfer a message.
        // It pushes a message to the queue and signals the event.
        static void ReceiveMessage(const char* destination, const char* message)
        {
            std::lock_guard<std::mutex> locker(m_mutex);
            m_messages.push(message);
            std::wcout << "ReceiveMessage: "
                << "destination: " << destination
                << "message: " << message << std::endl;
            ::SetEvent(m_event);
        }

    public:
        Connector()
        {
            if (m_event = ::CreateEventW(NULL, TRUE, FALSE, NULL);
                !m_event)
            {
                throw std::runtime_error("Cannot create an event in Connector.");
            }

            if (s_library = ::LoadLibraryW(CONNECTOR_DLL_FILE.wstring().c_str());
                !s_library)
            {
                throw std::runtime_error("Cannot load agent_connector.dll");
            }

            const struct
            {
                void** address;
                const char* name;
            } importFunctions[]
            {
                { reinterpret_cast<void**>(&fn_agent_connector_symbols), "agent_connector_symbols"},
                { reinterpret_cast<void**>(&fn_initialize_agent), "initialize_agent"},
                { reinterpret_cast<void**>(&fn_sendMessage), "sendMessage"}
            };

            for (auto f : importFunctions)
            {
                *(f.address) = ::GetProcAddress(s_library, f.name);
                if (*(f.address) == nullptr)
                {
                    const std::string message{ std::string("Cannot get adresses of procedure: ") + f.name + "in " + CONNECTOR_DLL_FILE.string() };
                    throw std::runtime_error(message);
                }
            }
        }

        ~Connector() override
        {
            ::SetEvent(m_event); // to finish all waits
            ::WaitForSingleObject(m_event, 0);
            ::CloseHandle(m_event);

            if (s_library != nullptr)
            {
                if (!::FreeLibrary(s_library))
                {
                    std::wcout << L"Failed to unload library " << CONNECTOR_DLL_FILE.wstring() << std::endl;
                }
            }
        }

        void InitializeAgent() override
        {
            std::wcout << "Connector::InitializeAgent start." << std::endl;
            agent_connector_ExportedSymbols* ptr = fn_agent_connector_symbols();
            void (*fun)(const char*, const char*) = ReceiveMessage;
            void* function = (void*)(fun);
            fn_initialize_agent("mysuperAgent", "localhost:8090", "1.0.0", "group", "fail", function);
            std::wcout << "Connector::InitializeAgent end." << std::endl;
        }

        void SendMessage1(const std::string& content) override
        {
            std::wcout << "Connector::SendMessage1: '" << content.c_str() << "'" << std::endl;
            fn_sendMessage("10", content.c_str());
        }

        std::optional<std::string> GetNextMessage() override
        {
            std::string result;
            std::lock_guard<std::mutex> locker(m_mutex);
            if (!m_messages.empty())
            {
                result = m_messages.front();
                m_messages.pop();
                return result;
            }
            return std::nullopt;
        }

        void WaitForNextMessage(DWORD timeout) override
        {
            DWORD waitResult = ::WaitForSingleObject(m_event, timeout);
            switch (waitResult)
            {
                case WAIT_OBJECT_0:
                case WAIT_TIMEOUT:
                    return;
                case WAIT_ABANDONED:
                case WAIT_FAILED:
                default:
                    throw std::runtime_error("WaitForSingleObject failed.");
            }
        }
    };

    const std::filesystem::path Connector::CONNECTOR_DLL_FILE{ L"agent_connector.dll" };
    HMODULE Connector::s_library = nullptr;
    decltype(agent_connector_symbols)* Connector::fn_agent_connector_symbols;
    decltype(initialize_agent)* Connector::fn_initialize_agent;
    decltype(sendMessage)* Connector::fn_sendMessage;
    std::queue<std::string> Connector::m_messages;
    std::mutex Connector::m_mutex;
    HANDLE Connector::m_event{ nullptr };

    std::shared_ptr<IConnector> IConnector::CreateInstance()
    {
        return std::make_shared<Connector>();
    }
}
