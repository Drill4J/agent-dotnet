#pragma once

#include "Connector.h"

// A hack to solve GNU-specific artifact generated by Kotlin native 1.3.70
#define __attribute__(x) 
#include <agent_connector_api.h>
#undef  __attribute__

#include <typeinfo>
#include <stdexcept>
#include <iostream>
#include <filesystem>
#include <queue>
#include <mutex>
#include <concepts>
#include "../Drill4dotNet/OutputUtils.h"
#include <nlohmann/json.hpp>

EXTERN_C IMAGE_DOS_HEADER __ImageBase;

namespace Drill4dotNet
{
    class DllLoader
    {
    private:
        class Deleter
        {
        private:
            const std::filesystem::path m_fileName;

        public:
            Deleter(const std::filesystem::path& fileName)
                : m_fileName(fileName)
            {
            }

            void operator()(const HMODULE library) const noexcept
            {
                if (library == nullptr)
                {
                    return;
                }

                if (::FreeLibrary(library) == FALSE)
                {
                    std::wcout
                        << L"Failed to unload library "
                        << m_fileName.wstring()
                        << std::endl;
                }
            }
        };

        using UniquePtr = std::unique_ptr<std::remove_pointer_t<HMODULE>, Deleter>;

        static UniquePtr Create(const std::filesystem::path& fileName)
        {
            Deleter deleter { fileName };

            const HMODULE nakedPointer { ::LoadLibraryW(fileName.wstring().c_str()) };
            if (nakedPointer == nullptr)
            {
                throw std::runtime_error(
                    std::string { "Cannot load " } + fileName.string());
            }

            return UniquePtr(nakedPointer, std::move(deleter));
        }

        UniquePtr m_handle;

        static const std::filesystem::path ResolveAbsolutePath(const std::filesystem::path& name)
        {
            const HMODULE hCurrentModule = reinterpret_cast<HMODULE>(&__ImageBase);
            DWORD rSize = _MAX_PATH;
            std::wstring currentModuleFileName(_MAX_PATH, L'\0');
            do
            {
                currentModuleFileName.resize(rSize, L'\0');
                rSize = ::GetModuleFileName(hCurrentModule, currentModuleFileName.data(), static_cast<unsigned long>(currentModuleFileName.size()));
                rSize *= 2;
            } while (::GetLastError() == ERROR_INSUFFICIENT_BUFFER);
            TrimTrailingNulls(currentModuleFileName);

            const std::filesystem::path absolutePath = std::filesystem::path(currentModuleFileName).parent_path() / name;
            std::wcout
                << "ResolveAbsolutePath: "
                << absolutePath.wstring()
                << std::endl;
            return absolutePath;
        }

    public:
        explicit DllLoader(const std::filesystem::path& fileName)
            : m_handle{ Create(ResolveAbsolutePath(fileName)) }
        {
        }

        HMODULE Handle() const noexcept
        {
            return m_handle.get();
        }
    };

    class AgentConnectorDllLoader
        : public DllLoader
    {
    private:
        inline static const std::filesystem::path CONNECTOR_DLL_FILE{ L"agent_connector.dll" };

        template <typename T>
        T ImportFunction(LPCSTR const name)
        {
            void* result = ::GetProcAddress(Handle(), name);
            if (result == nullptr)
            {
                throw std::runtime_error(
                    std::string("Cannot get address of procedure: ")
                    + name
                    + " in "
                    + CONNECTOR_DLL_FILE.string());
            }

            return reinterpret_cast<T>(result);
        }
    public:
        decltype(::agent_connector_symbols)* const agent_connector_symbols;
        decltype(::initialize_agent)* const initialize_agent;
        decltype(::sendMessage)* const sendMessage;
        decltype(::sendPluginMessage)* const sendPluginMessage;

        AgentConnectorDllLoader()
            : DllLoader{ CONNECTOR_DLL_FILE },
            agent_connector_symbols { ImportFunction<decltype(agent_connector_symbols)>("agent_connector_symbols") },
            initialize_agent { ImportFunction<decltype(initialize_agent)>("initialize_agent") },
            sendMessage { ImportFunction<decltype(sendMessage)>("sendMessage") },
            sendPluginMessage{ ImportFunction<decltype(sendPluginMessage)>("sendPluginMessage") }
        {
        }
    };

    class Event
    {
    private:
        class Deleter
        {
        public:
            void operator()(const HANDLE event) const noexcept
            {
                if (event != nullptr)
                {
                    if (::CloseHandle(event) == FALSE)
                    {
                        std::wcout
                            << L"Failed to close event handle."
                            << std::endl;
                    }
                }
            }
        };

        using UniquePtr = std::unique_ptr<std::remove_pointer_t<HANDLE>, Deleter>;
        UniquePtr m_handle;

    public:
        Event(
            LPSECURITY_ATTRIBUTES securityAttributes,
            BOOL manualReset,
            BOOL initialState,
            LPCWSTR const name)
            : m_handle { ::CreateEventW(
                    securityAttributes,
                    manualReset,
                    initialState,
                    name) }
        {
            if (m_handle.get() == nullptr)
            {
                throw std::runtime_error("Cannot create an event in Connector");
            }
        }

        HANDLE Handle() const noexcept
        {
            return m_handle.get();
        }
    };

    // Converts a UTF-8 string to a std::wstring.
    // Throws std::runtime_error in case of an error.
    static std::wstring DecodeUtf8(const std::string& string)
    {
        if (string == "")
        {
            return std::wstring{};
        }

        std::wstring result(
            MultiByteToWideChar(
                CP_UTF8,
                MB_ERR_INVALID_CHARS,
                string.c_str(),
                string.size(),
                nullptr,
                0),
            L'\0');

        if (MultiByteToWideChar(
            CP_UTF8,
            MB_ERR_INVALID_CHARS,
            string.c_str(),
            string.size(),
            result.data(),
            result.size()) == 0)
        {
            throw std::runtime_error("Could no decode UTF-8: Invalid UTF-8 string.");
        }

        return result;
    }

    // Converts the given string to UTF-8.
    // Throws std::runtime_error in case of an error.
    static std::string EncodeUtf8(const std::wstring& source)
    {
        if (source == L"")
        {
            return {};
        }


        std::string result(
            WideCharToMultiByte(
                CP_UTF8,
                WC_ERR_INVALID_CHARS,
                source.c_str(),
                source.size(),
                nullptr,
                0,
                nullptr,
                nullptr),
            '\0');

        if (WideCharToMultiByte(
            CP_UTF8,
            WC_ERR_INVALID_CHARS,
            source.c_str(),
            source.size(),
            result.data(),
            result.size(),
            nullptr,
            nullptr) == 0)
        {
            throw std::runtime_error("Could no encode UTF-8: Invalid UTF-16 string.");
        }

        return result;
    }

    // Converts an AstMethod object to json format.
    static void to_json(nlohmann::json& target, const AstMethod& data)
    {
        std::vector<std::string> params{};
        params.reserve(data.params.size());
        for (const auto& param : data.params)
        {
            params.push_back(EncodeUtf8(param));
        }

        target = nlohmann::json{
            { "name", EncodeUtf8(data.name) },
            { "params", params },
            { "returnType", EncodeUtf8(data.returnType) },
            { "count", data.count },
            { "probes", data.probes }
        };
    }

    // Gets an AstMethod object from json.
    static void from_json(const nlohmann::json& source, AstMethod& target)
    {
        target.name = DecodeUtf8(source.at("name").get<std::string>());

        std::vector<std::string> params { source.at("params").get<std::vector<std::string>>() };
        target.params.clear();
        target.params.reserve(params.size());
        for (const auto& param : params)
        {
            target.params.push_back(DecodeUtf8(param));
        }

        target.returnType = DecodeUtf8(source.at("returnType").get<std::string>());

        source.at("count").get_to(target.count);
        source.at("probes").get_to(target.probes);
    }

    // Converts an AstEntity object to json format.
    static void to_json(nlohmann::json& target, const AstEntity& data)
    {
        target = nlohmann::json{
            { "path", EncodeUtf8(data.path) },
            { "name", EncodeUtf8(data.name) },
            { "methods", data.methods }
        };
    }

    // Gets an AstEntity object from json.
    static void from_json(const nlohmann::json& source, AstEntity& target)
    {
        target.path = DecodeUtf8(source.at("path").get<std::string>());
        target.name = DecodeUtf8(source.at("name").get<std::string>());
        source.at("methods").get_to(target.methods);
    }

    // Sent to Drill admin to notify that classes data will be sent.
    class InitInfo
    {
    public:
        std::string type { "INIT" };
        uint32_t classesCount;
        std::string message { "" };
        bool init { true };

        InitInfo(uint32_t classesCount)
            : classesCount { classesCount }
        {
        }
    };

    // Converts an InitInfo object to json format.
    static void to_json(nlohmann::json& target, const InitInfo& data)
    {
        target = nlohmann::json{
            { "type", data.type },
            { "classesCount", data.classesCount },
            { "message", data.message },
            { "init", data.init }
        };
    }

    // Gets an InitInfo object from json.
    static void from_json(const nlohmann::json& source, InitInfo& target)
    {
        source.at("type").get_to(target.type);
        source.at("classesCount").get_to(target.classesCount);
        source.at("message").get_to(target.message);
        source.at("init").get_to(target.init);
    }

    // Sent to Drill admin to provide information about classes.
    class InitDataPart
    {
    public:
        std::string type { "INIT_DATA_PART" };
        std::vector<AstEntity> astEntities;

        InitDataPart(std::vector<AstEntity> astEntities)
            : astEntities { std::move(astEntities) }
        {
        }
    };

    // Converts an InitDataPart object to json format.
    static void to_json(nlohmann::json& target, const InitDataPart& data)
    {
        target = nlohmann::json{
            { "type", data.type },
            { "astEntities", data.astEntities }
        };
    }

    // Gets an InitDataPart object from json.
    static void from_json(const nlohmann::json& source, InitDataPart& target)
    {
        source.at("type").get_to(target.type);
        source.at("astEntities").get_to(target.astEntities);
    }

    // Sent to Drill admin to notify that all information about classes was sent.
    class Initialized
    {
    public:
        std::string type { "INITIALIZED" };
        std::string msg { "" };
    };

    // Converts an Initialized object to json format.
    static void to_json(nlohmann::json& target, const Initialized& data)
    {
        target = nlohmann::json{
            { "type", data.type },
            { "msg", data.msg }
        };
    }

    // Gets an Initialized object from json.
    static void from_json(const nlohmann::json& source, Initialized& target)
    {
        source.at("type").get_to(target.type);
        source.at("msg").get_to(target.msg);
    }

    // Converts a PackagesPrefixes object to json format.
    static void to_json(nlohmann::json& target, const PackagesPrefixes& data)
    {
        std::vector<std::string> packagesPrefixes{};
        packagesPrefixes.reserve(data.packagesPrefixes.size());
        for (const auto& item : data.packagesPrefixes)
        {
            packagesPrefixes.push_back(EncodeUtf8(item));
        }

        target = nlohmann::json { { "packagesPrefixes", packagesPrefixes } };
    }

    // Gets a PackagesPrefixes object from json.
    static void from_json(const nlohmann::json& source, PackagesPrefixes& target)
    {
        std::vector<std::string> packagesPrefixes { source.at("packagesPrefixes").get<std::vector<std::string>>() };
        target.packagesPrefixes.clear();
        target.packagesPrefixes.reserve(packagesPrefixes.size());
        for (const auto& item : packagesPrefixes)
        {
            target.packagesPrefixes.push_back(DecodeUtf8(item));
        }
    }

    // Converts a PluginAction object to json format.
    static void to_json(nlohmann::json& target, const PluginAction& data)
    {
        target = nlohmann::json {
            { "id", EncodeUtf8(data.id) },
            { "message", EncodeUtf8(data.message) }
        };
    }

    // Gets a PluginAction object from json.
    static void from_json(const nlohmann::json& source, PluginAction& target)
    {
        target.id = DecodeUtf8(source.at("id").get<std::string>());
        target.message = DecodeUtf8(source.at("message").get<std::string>());
    }

    // Converts a SessionPayload object to json format.
    static void to_json(nlohmann::json& target, const SessionPayload& data)
    {
        target = nlohmann::json { { "sessionId", EncodeUtf8(data.sessionId) } };
    }

    // Gets a SessionPayload object from json.
    static void from_json(const nlohmann::json& source, SessionPayload& target)
    {
        target.sessionId = DecodeUtf8(source.at("sessionId").get<std::string>());
    }

    // Converts a StopSession object to json format.
    static void to_json(nlohmann::json& target, const StopSession& data)
    {
        target = nlohmann::json {
            { "type", data.type },
            { "payload", data.payload }
        };
    }

    // Gets a StopSession object from json.
    static void from_json(const nlohmann::json& source, StopSession& target)
    {
        source.at("type").get_to(target.type);
        source.at("payload").get_to(target.payload);
    }

    // Converts a StartPayload object to json format.
    static void to_json(nlohmann::json& target, const StartPayload& data)
    {
        target = nlohmann::json {
            { "testType", EncodeUtf8(data.testType) },
            { "sessionId", EncodeUtf8(data.sessionId) }
        };
    }

    // Gets a StartPayload object from json.
    static void from_json(const nlohmann::json& source, StartPayload& target)
    {
        target.testType = DecodeUtf8(source.at("testType").get<std::string>());
        target.sessionId = DecodeUtf8(source.at("sessionId").get<std::string>());
    }

    // Converts a StartSessionHttpRequest object to json format.
    static void to_json(nlohmann::json& target, const StartSessionHttpRequest& data)
    {
        target = nlohmann::json {
            { "type", data.type },
            { "payload", data.payload }
        };
    }

    // Gets a StartSessionHttpRequest object from json.
    static void from_json(const nlohmann::json& source, StartSessionHttpRequest& target)
    {
        source.at("type").get_to(target.type);
        source.at("payload").get_to(target.payload);
    }

    // Converts a StartSessionPayload object to json format.
    static void to_json(nlohmann::json& target, const StartSessionPayload& data)
    {
        target = nlohmann::json {
            { "sessionId", EncodeUtf8(data.sessionId) },
            { "startPayload", data.startPayload }
        };
    }

    // Gets a StartSessionPayload object from json.
    static void from_json(const nlohmann::json& source, StartSessionPayload& target)
    {
        target.sessionId = DecodeUtf8(source.at("sessionId").get<std::string>());
        source.at("startPayload").get_to(target.startPayload);
    }

    // Converts a StartSession object to json format.
    static void to_json(nlohmann::json& target, const StartSession& data)
    {
        target = nlohmann::json {
            { "type", data.type },
            { "payload", data.payload }
        };
    }

    // Gets a StartSession object from json.
    static void from_json(const nlohmann::json& source, StartSession& target)
    {
        source.at("type").get_to(target.type);
        source.at("payload").get_to(target.payload);
    }

    // Converts a SessionStarted object to json format.
    static void to_json(nlohmann::json& target, const SessionStarted& data)
    {
        target = nlohmann::json {
            { "type", data.type },
            { "sessionId", EncodeUtf8(data.sessionId) },
            { "testType", EncodeUtf8(data.testType) },
            { "ts", data.ts }
        };
    }

    // Gets a SessionStarted object from json.
    static void from_json(const nlohmann::json& source, SessionStarted& target)
    {
        source.at("type").get_to(target.type);
        target.sessionId = DecodeUtf8(source.at("sessionId").get<std::string>());
        target.testType = DecodeUtf8(source.at("testType").get<std::string>());
        source.at("ts").get_to(target.ts);
    }

    // Converts a SessionCancelled object to json format.
    static void to_json(nlohmann::json& target, const SessionCancelled& data)
    {
        target = nlohmann::json {
            { "type", data.type },
            { "sessionId", EncodeUtf8(data.sessionId) },
            { "ts", data.ts}
        };
    }

    // Gets a SessionCancelled object from json.
    static void from_json(const nlohmann::json& source, SessionCancelled& target)
    {
        source.at("type").get_to(target.type);
        target.sessionId = DecodeUtf8(source.at("sessionId").get<std::string>());
        source.at("ts").get_to(target.ts);
    }

    // Converts a AllSessionsCancelled object to json format.
    static void to_json(nlohmann::json& target, const AllSessionsCancelled& data)
    {
        std::vector<std::string> ids{};
        ids.reserve(data.ids.size());
        for (const auto& id : data.ids)
        {
            ids.push_back(EncodeUtf8(id));
        }

        target = nlohmann::json {
            { "type", data.type },
            { "ids", ids },
            { "ts", data.ts}
        };
    }

    // Gets a AllSessionsCancelled object from json.
    static void from_json(const nlohmann::json& source, AllSessionsCancelled& target)
    {
        source.at("type").get_to(target.type);
        std::vector<std::string> ids { source.at("ids").get<decltype(ids)>() };
        target.ids.clear();
        target.ids.reserve(ids.size());
        for (const auto& id : ids)
        {
            target.ids.push_back(DecodeUtf8(id));
        }

        source.at("ts").get_to(target.ts);
    }

    // Converts a ExecClassData object to json format.
    static void to_json(nlohmann::json& target, const ExecClassData& data)
    {
        target = nlohmann::json {
            { "id", data.id },
            { "className", EncodeUtf8(data.className) },
            { "probes", data.probes },
            { "testName", EncodeUtf8(data.testName) }
        };
    }

    // Gets a ExecClassData object from json.
    static void from_json(const nlohmann::json& source, ExecClassData& target)
    {
        source.at("id").get_to(target.id);
        target.className = DecodeUtf8(source.at("className").get<std::string>());
        source.at("probes").get_to(target.probes);
        target.testName = DecodeUtf8(source.at("testName").get<std::string>());
    }

    // Converts a CoverDataPart object to json format.
    static void to_json(nlohmann::json& target, const CoverDataPart& data)
    {
        target = nlohmann::json {
            { "type", data.type },
            { "sessionId", EncodeUtf8(data.sessionId) },
            { "data", data.data }
        };
    }

    // Gets a CoverDataPart object from json.
    static void from_json(const nlohmann::json& source, CoverDataPart& target)
    {
        source.at("type").get_to(target.type);
        target.sessionId = DecodeUtf8(source.at("sessionId").get<std::string>());
        source.at("data").get_to(target.data);
    }

    // Converts a SessionChanged object to json format.
    static void to_json(nlohmann::json& target, const SessionChanged& data)
    {
        target = nlohmann::json {
            { "type", data.type },
            { "sessionId", EncodeUtf8(data.sessionId) },
            { "probeCount", data.probeCount }
        };
    }

    // Gets a SessionChanged object from json.
    static void from_json(const nlohmann::json& source, SessionChanged& target)
    {
        source.at("type").get_to(target.type);
        target.sessionId = DecodeUtf8(source.at("sessionId").get<std::string>());
        source.at("probeCount").get_to(target.probeCount);
    }

    // Converts a SessionFinished object to json format.
    static void to_json(nlohmann::json& target, const SessionFinished& data)
    {
        target = nlohmann::json {
            { "type", data.type },
            { "sessionId", EncodeUtf8(data.sessionId) },
            { "ts", data.ts }
        };
    }

    // Gets a SessionFinished object from json.
    static void from_json(const nlohmann::json& source, SessionFinished& target)
    {
        source.at("type").get_to(target.type);
        target.sessionId = DecodeUtf8(source.at("sessionId").get<std::string>());
        source.at("ts").get_to(target.ts);
    }

    // Converts a ScopeInitialized object to json format.
    static void to_json(nlohmann::json& target, const ScopeInitialized& data)
    {
        target = nlohmann::json {
            { "type", data.type },
            { "id", EncodeUtf8(data.id) },
            { "name", EncodeUtf8(data.name) },
            { "prevId", EncodeUtf8(data.prevId) },
            { "ts", data.ts }
        };
    }

    // Gets a ScopeInitialized object from json.
    static void from_json(const nlohmann::json& source, ScopeInitialized& target)
    {
        source.at("type").get_to(target.type);
        target.id = DecodeUtf8(source.at("id").get<std::string>());
        target.name = DecodeUtf8(source.at("name").get<std::string>());
        target.prevId = DecodeUtf8(source.at("prevId").get<std::string>());
        source.at("ts").get_to(target.ts);
    }

    // Converts a InitScopePayload object to json format.
    static void to_json(nlohmann::json& target, const InitScopePayload& data)
    {
        target = nlohmann::json {
            { "id", EncodeUtf8(data.id) },
            { "name", EncodeUtf8(data.name) },
            { "prevId", EncodeUtf8(data.prevId) }
        };
    }

    // Gets a InitScopePayload object from json.
    static void from_json(const nlohmann::json& source, InitScopePayload& target)
    {
        target.id = DecodeUtf8(source.at("id").get<std::string>());
        target.name = DecodeUtf8(source.at("name").get<std::string>());
        target.prevId = DecodeUtf8(source.at("prevId").get<std::string>());
    }

    // Converts a InitActiveScope object to json format.
    static void to_json(nlohmann::json& target, const InitActiveScope& data)
    {
        target = nlohmann::json {
            { "type", data.type },
            { "payload", data.payload }
        };
    }

    // Gets a InitActiveScope object from json.
    static void from_json(const nlohmann::json& source, InitActiveScope& target)
    {
        source.at("type").get_to(target.type);
        source.at("payload").get_to(target.payload);
    }

    static int64_t GetCurrentTimeMillis()
    {
        const std::chrono::system_clock::time_point now {
            std::chrono::system_clock::now() };

        std::tm zero {
           .tm_sec = 0,
           .tm_min = 0,
           .tm_hour = 0,
           .tm_mday = 1,
           .tm_mon = 0,
           .tm_year = 1970 - 1900 };

        std::chrono::system_clock::time_point zeroPoint {
            std::chrono::system_clock::from_time_t(
                mktime(&zero)) };
        return std::chrono::duration_cast<std::chrono::milliseconds>(
            now - zeroPoint).count();
    }

    template <
        IsTreeProvider TreeProvider,
        IsPackagesPrefixesHandler PackagesPrefixesHandler>
    class Connector
    {
    protected:
        const AgentConnectorDllLoader m_agentLibrary{};

        TreeProvider m_treeProvider;
        PackagesPrefixesHandler m_packagesPrefixesHandler;
        std::queue<ConnectorQueueItem> m_messages;
        std::mutex m_mutex;
        Event m_event { NULL, TRUE, FALSE, NULL };

        // a hack for static callback; it should be replaced by context parameter of callback
        inline static Connector* s_connector;
    protected:
        // is called by Kotlin native connector to transfer a message.
        // It pushes a message to the queue and signals the event.
        static void ReceiveMessage(const char* destination, const char* message)
        {
            if (s_connector)
            {
                std::wcout << "ReceiveMessage: "
                    << "destination: " << destination
                    << " message: " << message
                    << std::endl;
                if (std::string { "/agent/load" } == destination)
                {
                    std::vector<AstEntity> classes { s_connector->m_treeProvider() };
                    const std::string pluginName { "test2code" };

                    // send INIT
                    nlohmann::json initMessage = InitInfo { static_cast<uint32_t>(classes.size()) };
                    s_connector->SendPluginMessage(
                        pluginName,
                        initMessage.dump());

                    // send INIT_DATA_PART
                    nlohmann::json initDataPartMessage = InitDataPart(classes);
                    s_connector->SendPluginMessage(
                        pluginName,
                        initDataPartMessage.dump());

                    // send INITIALIZED
                    nlohmann::json initializedMessage = Initialized{};
                    s_connector->SendPluginMessage(
                        pluginName,
                        initializedMessage.dump());
                }
                else if (std::string { "/agent/set-packages-prefixes" } == destination)
                {
                    s_connector->m_packagesPrefixesHandler(nlohmann::json::parse(message).get<PackagesPrefixes>());
                }
                else if (std::string { "/plugin/action" } == destination)
                {
                    PluginAction wrapper { nlohmann::json::parse(message).get<PluginAction>() };
                    nlohmann::json messageText { nlohmann::json::parse(wrapper.message) };
                    std::string discriminator { messageText.at("type").get<std::string>() };
                    if (discriminator == StartSession::Discriminator)
                    {
                        StartSession startSession { messageText.get<StartSession>() };
                        nlohmann::json startMessage = SessionStarted {
                            startSession.payload.startPayload.sessionId,
                            startSession.payload.startPayload.testType,
                            GetCurrentTimeMillis() };
                        s_connector->SendPluginMessage(
                            "test2code",
                            startMessage.dump());
                    }
                    else if (discriminator == StopSession::Discriminator)
                    {
                        StopSession stopSession{ messageText.get<StopSession>() };
                        nlohmann::json coverageDataPart = CoverDataPart{
                            stopSession.payload.sessionId,
                            std::vector{
                                ExecClassData{
                                    .id = 0,
                                    .className = L"my_path/my_name",
                                    .probes = { true },
                                    .testName = L"my_test"
                                }
                            }
                        };

                        s_connector->SendPluginMessage(
                            "test2code",
                            coverageDataPart.dump());

                        nlohmann::json stopMessage = SessionFinished {
                            stopSession.payload.sessionId,
                            GetCurrentTimeMillis() };

                        s_connector->SendPluginMessage(
                            "test2code",
                            stopMessage.dump());
                    }
                    else if (discriminator == InitActiveScope::Discriminator)
                    {
                        InitActiveScope init { messageText.get<decltype(init)>() };
                        nlohmann::json initMessage = ScopeInitialized {
                            init.payload.id,
                            init.payload.name,
                            init.payload.prevId,
                            GetCurrentTimeMillis() };

                        s_connector->SendPluginMessage(
                            "test2code",
                            initMessage.dump());
                    }
                }
            }
        }

    public:
        Connector(
            TreeProvider treeProvider,
            PackagesPrefixesHandler packagesPrefixesHandler)
            : m_treeProvider { std::move(treeProvider) },
            m_packagesPrefixesHandler { std::move(packagesPrefixesHandler) }
        {
            s_connector = this;
        }

        ~Connector()
        {
            ::SetEvent(m_event.Handle()); // to finish all waits
            ::WaitForSingleObject(m_event.Handle(), 0);
        }

        TreeProvider& TreeProvider() &
        {
            return m_treeProvider;
        }

        PackagesPrefixesHandler& PackagesPrefixesHandler() &
        {
            return m_packagesPrefixesHandler;
        }

        void InitializeAgent()
        {
            std::wcout << "Connector::InitializeAgent start." << std::endl;
            agent_connector_ExportedSymbols* ptr = m_agentLibrary.agent_connector_symbols();
            void (*fun)(const char*, const char*) = ReceiveMessage;
            void* function = (void*)(fun);
            m_agentLibrary.initialize_agent(
                "mysuperAgent",
                "localhost:8090",
                "1.0.0",
                "",
                "fail",
                function);
            std::wcout << "Connector::InitializeAgent end." << std::endl;
        }

        void SendAgentMessage(
            const std::string& messageType,
            const std::string& destination,
            const std::string& content)
        {
            std::cout
                << "Connector::SendAgentMessage: { MessageType = "
                << messageType
                << ", Destination = "
                << destination
                << ", Content = "
                << content
                << "}"
                << std::endl;

            m_agentLibrary.sendMessage(
                messageType.c_str(),
                destination.c_str(),
                content.c_str());
        }

        void SendPluginMessage(
            const std::string& pluginId,
            const std::string& content)
        {
            std::cout
                << "Connector::SendPluginMessage: { PluginId = "
                << pluginId
                << ", Content = "
                << content
                << "}"
                << std::endl;

            m_agentLibrary.sendPluginMessage(
                pluginId.c_str(),
                content.c_str());
        }

        std::optional<ConnectorQueueItem> GetNextMessage()
        {
            std::lock_guard<std::mutex> locker(m_mutex);
            if (!m_messages.empty())
            {
                const ConnectorQueueItem result { m_messages.front() };
                m_messages.pop();
                return result;
            }

            return std::nullopt;
        }

        void WaitForNextMessage(DWORD timeout = INFINITE)
        {
            DWORD waitResult = ::WaitForSingleObject(m_event.Handle(), timeout);
            switch (waitResult)
            {
            case WAIT_OBJECT_0:
            case WAIT_TIMEOUT:
                return;
            case WAIT_ABANDONED:
            case WAIT_FAILED:
            default:
                throw std::runtime_error("WaitForSingleObject failed.");
            }
        }
    };

    class TrivialTreeProvider
    {
    public:
        std::vector<AstEntity> operator()() const
        {
            return {};
        }
    };

    class TrivialPackagesPrefixesHandler
    {
    public:
        void operator()(const PackagesPrefixes prefixes) const
        {
        }
    };

    static_assert(IsConnector<Connector<TrivialTreeProvider, TrivialPackagesPrefixesHandler>>);
}
