#pragma once

#include "IConnector.h"

// A hack to solve GNU-specific artifact generated by Kotlin native 1.3.70
#define __attribute__(x) 
#include <agent_connector_api.h>
#undef  __attribute__

#include <typeinfo>
#include <stdexcept>
#include <iostream>
#include <filesystem>
#include <queue>
#include <mutex>
#include <concepts>
#include "OutputUtils.h"
#include <nlohmann/json.hpp>

EXTERN_C IMAGE_DOS_HEADER __ImageBase;

namespace Drill4dotNet
{
    class Connector
    {
    private:
        class DllLoader
        {
        private:
            class Deleter
            {
            private:
                const std::filesystem::path m_fileName;

            public:
                Deleter(const std::filesystem::path& fileName);

                void operator()(const HMODULE library) const noexcept;
            };

            using UniquePtr = std::unique_ptr<std::remove_pointer_t<HMODULE>, Deleter>;

            static UniquePtr Create(const std::filesystem::path& fileName);

            UniquePtr m_handle;

            static const std::filesystem::path ResolveAbsolutePath(const std::filesystem::path& name);

        public:
            explicit DllLoader(const std::filesystem::path& fileName);

            HMODULE Handle() const noexcept;
        };

        class AgentConnectorDllLoader
            : public DllLoader
        {
        private:
            inline static const std::filesystem::path CONNECTOR_DLL_FILE{ L"agent_connector.dll" };

            template <typename T>
            T ImportFunction(LPCSTR const name);

        public:
            decltype(::agent_connector_symbols)* const agent_connector_symbols;
            decltype(::initialize_agent)* const initialize_agent;
            decltype(::sendMessage)* const sendMessage;
            decltype(::sendPluginMessage)* const sendPluginMessage;

            AgentConnectorDllLoader();
        };

        const AgentConnectorDllLoader m_agentLibrary{};
        const ConnectorReceiveCallback m_callback;

    public:
        Connector(ConnectorReceiveCallback callback);

        void InitializeAgent();

        void SendAgentMessage(
            const std::string& messageType,
            const std::string& destination,
            const std::string& content);

        void SendPluginMessage(
            const std::string& pluginId,
            const std::string& content);
    };
}
